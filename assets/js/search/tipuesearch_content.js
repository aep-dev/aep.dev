var tipuesearch = {'pages': [
{
    'title': "AEP Purpose and Guidelines",
    'text': "AEP Purpose and Guidelines Service APIs on the Internet continue to proliferate; having a machine-readable API is an expectation and prerequisite to adoption for many services. By some estimates, there are now more than 20,000 public REST APIs available. As this corpus continues to grow, many companies struggle with API Governance: even as companies grow and disparate teams work to deliver discrete services, APIs ought to remain simple, intuitive, and consistent. Therefore, it is increasingly necessary to have a corpus of documentation for API producers, reviewers, and other interested parties to reference. The AEP collection provides a way to provide consistent documentation for API design guidance. What is an AEP? AEP stands for API Enhancement Proposal, which is a design document providing high-level, concise documentation for API development. Companies that adopt the AEP program use them as a source of truth for API-related documentation, and the means by which service producers discuss and come to consensus on API guidance. AEPs are maintained as Markdown files with metadata in the AEP GitHub repository. Adopting AEPs Companies may adopt the AEP system in one of two ways: By applying the guidance described at aep.dev. By \"forking\" the AEP system and setting up their own subdomain. Companies with an already-established corpus of services are unlikely to have exactly followed the guidance at aep.dev. Forking the system is valuable because the guidance becomes comparable. Forks must retain the same numbering system (AEP-2) to provide that comparability. Technical leadership The AEP system, as well as the guidance on aep.dev, is overseen by the AEP technical steering committee. The committee is the set of people who make decisions on AEPs. The general goal is that the AEP process is collaborative and that we largely work on the basis of consensus. However, a limited number of designated approvers is necessary, and these committee members will be approvers for each AEP on aep.dev. The technical steering committee membership is currently: Antoine Boyer (@tinnou), Netflix Ross Hamilton (@rhamiltonsf), Salesforce Mike Kistler (@mkistler), IBM Luke Sneeringer (@lukesneeringer), Google The committee is also responsible for the administrative and editorial aspects of shepherding AEPs and managing the AEP pipeline and workflow. They approve PRs to AEPs, assign proposal numbers, manage the agenda, set AEP states, and so forth. They also ensure that AEPs are readable (proper spelling, grammar, sentence structure, markup, etc.). Committee membership is by invitation of the current committee. The committee must not include more than two members from the same company. Note: Companies that maintain their own fork of aep.dev select their own leadership and have full control of their fork\u0027s content. States At any given time, AEPs may exist in a variety of states as they work their way through the process. The following is a summary of each state. Reviewing Initial discussion on most AEPs occurs in the initial pull request to submit the AEP. Once this PR is merged, the AEP exists in the \"Reviewing\" state. This means that the authors and the technical steering committee have reached a general consensus on the proposal. At this stage, the committee may request changes or suggest alternatives to the proposal before moving forward, but there is a general expectation that the proposal will move forward and it is usually safe to \"early adopt\" it. An AEP must be in the reviewing state for at least 14 days before being approved, and the committee should send appropriate communication regarding the pending approval. Note: As a formal matter, one AEP approver (other than the author) must provide formal signoff to advance an AEP to the reviewing state. Additionally, there must not be formal objections (\"changes requested\" on the GitHub PR) from other approvers. Approved Once an AEP has been agreed upon, it enters \"approved\" state and is considered \"best current practice\". AEPs may be edited after they are approved, either to correct grammar or word choices, or to clarify semantic guidance (in response to reader questions). In rare occasions, new guidance may be added. Clarifications and new guidance must be reflected in the changelog. Correction of typos or minor language alterations may be done silently. Note: As a formal matter, two AEP approvers (other than the author) must provide formal signoff to advance an AEP to the approved state. Additionally, there must not be formal objections (\"changes requested\" on the GitHub PR) from other approvers. Final If an AEP has been approved for a significant period and the technical steering committee is certain that no further guidance will be needed, they may move the AEP in to \"final\" state. AEPs in the final state must not be amended with new guidance. They may be editied to correct spelling, grammar, or clarity provided there are no semantic changes. Note: As a formal matter, two AEP approvers must provide formal signoff to advance an AEP to the final state. Additionally, there must not be formal objections (\"changes requested\" on the GItHub PR) from other approvers. Replaced If an AEP has been replaced by another AEP, it enters \"replaced\" state. The AEP must include a notice explaining the replacement and rationale (the replacement AEP should also clearly explain the rationale). In general, service producers rely primarily on AEPs in the \"approved\" state. Service producers may rely on AEPs in the \"reviewing\" state Withdrawn If an AEP is withdrawn by the author or champion, or is rejected by the technical steering committee after reaching the \"reviewing\" state, it enters \"withdrawn\" state. Withdrawn AEPs remain accessible, but are removed from the indexes; they provide documentation and reference to inform future discussions. Workflow The following workflow describes the process for proposing an AEP, and moving an AEP from proposal to implementation to final acceptance. Overview digraph d_front_back { rankdir=LR; node [ style=\"filled,solid\" shape=box fontname=\"Roboto\" ]; github_pr [ shape=\"oval\" label=\"GitHub PR\" fillcolor=\"orange\" ]; reviewing [ label=\"Reviewing\" fillcolor=\"lightskyblue\" ]; approved [ label=\"Approved\" fillcolor=\"palegreen\" ]; final [ label=\"Final\" fillcolor=\"palegreen\" ]; withdrawn [ label=\"Withdrawn\" fillcolor=\"mistyrose\" ]; replaced [ label=\"Replaced\" fillcolor=\"lightsteelblue\" ]; github_pr -\u003e reviewing; reviewing -\u003e approved; reviewing -\u003e withdrawn [ style=dashed, color=mistyrose3 ]; approved -\u003e final; approved -\u003e replaced [ style=dashed, color=lightsteelblue3 ]; final -\u003e replaced [ style=dashed color=lightsteelblue3 ]; } Proposing an AEP In order to propose an AEP, first open a pull request with a draft AEP; the AEP should conform to the guidance in AEP-8. Most AEPs should be no more than two pages if printed out. If the technical steering committee has suggested an AEP number, use that; otherwise use 99 (and expect to change it during the course of the review). Important: Ensure that the PR is editable by maintainers. In most circumstances, the committee will assign the proposal an AEP number and begin discussion. Once there is consensus, the committee will merge the PR, and the AEP will enter the \"reviewing\" state. The committee may reject an AEP outright if they have an obvious reason to do so (e.g. the proposal was already discussed and rejected in another AEP or is fundamentally unsound), in which case the PR is not merged. Accepting an AEP The editors will work together to ensure that qualified proposals do not linger in review. To gain final approval, an AEP must be approved by, at minimum, two members of the technical steering committee. Additionally, there should not be any committee members requesting significant changes (indicated by the use of the \"changes requested\" feature on GitHub). Note: If an AEP editor is the primary author of an AEP, then at least two other editors must approve it. Withdrawing or Rejecting an AEP The author of an AEP may decide, after further consideration, that an AEP should not advance. If so, the author may withdraw the AEP by updating the PR adding a notice of withdrawal with an explanation of the rationale. Additionally, the author may be unable to get consensus among the group and the technical steering committee may elect to reject the AEP. In this situation, the committee shall amend the PR adding a notice of rejection with an explanation of the rationale. In both cases, the committee must update the state accordingly and submit the PR. Replacing an AEP In rare cases, it may be necessary to replace an AEP with another one. This is not general practice: minor edits to approved AEPs are acceptable, and AEPs only enter final state when there is high confidence that further edits will not be necessary. However, if new guidance fundamentally alters the old guidance in some way, then the technical steering committee should create a new AEP that, once approved, will replace the old one. The old one then enters \"Replaced\" state, and will link to the new, current AEP.",
    'tags': '',
    'url': '/1',
  },
{
    'title': "AEP Numbering and Organization",
    'text': "AEP Numbering and Organization This document describes the numbering system and general organization of AEPs. AEP numbers: Are unique. No two AEPs share the same number. Indicate the order in which they are authored. To help with organization and discovery, AEPs also have a category and a slug to easily discovery and refer to the AEP. See below for an example of an AEP id, category, and slug, expressed via YAML front-matter: id: 11 category: \u0027resources\u0027 slug: \u0027create\u0027 AEP Numbers Core AEPs To uniquely identify an AEP, each one is assigned a permanent number as it is merged. A merged AEP must use the next available number. AEPs must be numbered between 1 and 9999. Organization-specific AEPs Organizations may extend the AEPs with guidance that is relevant to them. Organization-specific AEPs must use AEP numbers 10000 or greater. AEP Categories To help with discovery of an AEP, each one is assigned a category: a string that describes a theme or grouping the AEP belongs in. The category of an AEP may change over time. As an example, the guidance around custom methods may grow to multiple AEPs. As such, AEPS may create a new category \"custom-methods\" and recategorize relevant AEPs (mutating custom methods, retrieval custom methods) under it. Categories are expressed in the YAML front-matter of an AEP: category: \u0027custom-methods\u0027 AEP Slugs Each AEP is given a slug: a string by which it can be easily referenced and accessible via an URL on the aep.dev site. The slug of an AEP may change over time, sometimes to refer to a new revision of an existing AEP. On the AEP site, the AEP is then available by with a path of the slug: /{slug}. For example, an AEP-123 may author guidance around a design pattern for revisions of resources, and be given the slug \"revisions\". If a new AEP-1340 that provides a significant change is authored, then it may be use the slug \"revisions\", with AEP-123 given a slug like \"revisions-deprecated\". Slugs are expressed in the YAML front-matter of an AEP: slug: \u0027create\u0027 And is available via the path \"/create\" on the site hosting aep.dev. Rationale Why AEP Slugs In the original aip.dev project, numbers were the primary identifier for an AEP. However, as a number does not hint to its purpose or the guidance it contains, conversations around AIPs were difficult to hold and often the AIPs were be referred to by an unofficial colloquial name rather than by its number. As such, AEPs provide the ability for a semantic slug. Why AEP Categories With aip.dev, numbers were an organizational scheme, with AIPs sorted by number in navigation. Using numbers resulted in difficulties putting a new AEP alongside related AEPs if a number was not available. By adding categories, new AEPs can easily be organized, as well as produce more granular categories as the need arises. Why Organization-specific AEPs Similar to google.aip.dev, the organizations supporting the AEP project found the need for providing organization-specific guidance that is a superset of the open specification. By allocating a specific range, organizations may safely extend the AEPs without concern of conflicting AEP numbers.",
    'tags': '',
    'url': '/2',
  },
{
    'title': "Glossary",
    'text': "Glossary This AEP defines common terminology. Guidance The following terminology must be used consistently throughout AEPs. API Application Programming Interface. This can be a local interface (such as an SDK) or a Network API (defined below). APIs define one or more operations upon resource types. API Backend A set of servers and related infrastructure that implements the business logic for an API Service. API Client An API Client is a program or library that perform a specific tasks by calling an API or generic tools, such as CLIs, that expose the API in a user-accessible fashion or operate on resource data at rest. Examples of clients include the following: Command line interfaces Libraries, such as an SDK for a particular programming language Scripts that operates on a JSON representation of a resource after reading it from an API Tools, such as a [Declarative client][] Visual UIs, such as a web application API Definition A well-structured representation of an API. API Endpoint Refers to a network address that an API uses to handle incoming requests. One API may have multiple endpoints, such as https://pubsub.example.com and https://content-pubsub.example.com. API Gateway One or more services that together provide common functionality across API services, such as load balancing and authentication. API Method An individual operation within an API. It is typically represented in Protocol Buffers by an rpc definition, or in HTTP via a method and a path. API Name The name by which to refer to an API. API Request A single invocation of an API Method. It is often used as the unit for billing, logging, monitoring, and rate limiting. API Resource An entity upon which one or more methods can operate. API Resource Type The type of a API resource. It is globally unique within an API. API Service An implementation of an API, exposing API methods on one or more network addresses. Consumer Either a programmatic client or a user that consumes an API. This term should be used when a statement refers broadly to both programs and users. Declarative Clients Declarative Clients, also known as Infrastructure as Code (IaC), describes a category of clients that consumes a markup language or code that represents resources exposed by an API, and executes the appropriate imperative actions to drive the resource to that desired state. To determine what changes to make and if a set of updates was successful a declarative client compares server side resource attributes with client defined values. The comparison feature ensures accuracy of a creation or an update but it requires services to treat the client set fields as read-only and diligently preserve those values. Examples of complexities that declarative clients abstract away include: Determing the appropriate imperative action (create / update / delete) to achieve desired state. Ordering of these imperative actions. Terraform is an example of such a client. User A human being which is using an API directly, such as with cURL. This term is defined to differentiate usage in the AIPs between a human user and a programmatic client. Network API An API that operates across a network of computers. Network APIs communicate using network protocols including HTTP, and are frequently produced by organizations separate from those that consume them. Changelog",
    'tags': '',
    'url': '/3',
  },
{
    'title': "Resource types",
    'text': "Resource types Most APIs expose resources (their primary nouns) which users are able to create, retrieve, and manipulate. APIs are allowed to name their resource types as they see fit, and are only required to ensure uniqueness within that API. This means that it is possible (and often desirable) for different APIs to use the same type name. For example, a Memcache and Redis API would both want to use Instance as a type name. When mapping the relationships between APIs and their resources, however, it becomes important to have a single, globally-unique type name. Additionally, tools such as Kubernetes or GraphQL interact with APIs from multiple providers. Guidance APIs must define a resource type for each resource in the API, according to the following pattern: {API Name}/{Type Name}. The type name: must Only contain ASCII alphanumeric characters. must Start with a lowercase letter. must Be of the singular form of the noun. must Use kebab case. For Kubernetes, the type name when converted to UpperCamelCase must match the object name. For OpenAPI, the type name when converted to UpperCamelCase must match the name of the schema representing the object. For protobuf, the type name when converted to UpperCamelCase must match the name of the protobuf message. Examples Examples of resource types include: networking.istio.io/instance pubsub.example.com/topic pubsub.example.com/subscription spanner.example.com/database spanner.example.com/instance apis.example.com/user/user-event Annotating resource types APIs must annotate the resource types for each resource in the API Protocol buffers For protobuf, use the google.api.resource annotation: // A representation of a user event. message Topic { option (google.api.resource) = { type: \"user.example.com/user-event\" singular: \"user-event\" plural: \"user-events\" // define one or more patterns, e.g. if a resource has more than one parent. pattern: \"projects/{project}/user-events/{user-event}\" pattern: \"folder/{folder}/user-events/{user-event}\" pattern: \"users/{user}/events/{user-event}\" }; // Name and other fields... OpenAPI 3.0 For OpenAPI 3.0, use the x-aep-resource extension: { \"type\": \"object\", \"x-aep-resource\": { \"singular\": \"user-event\", \"plural\": \"user-events\", \"patterns\": [ \"projects/{project}/user-events/{user-event}\", \"folder/{folder}/user-events/{user-event}\", \"users/{user}/events/{user-event}\" ] } } The singular field must be the kebab-case singular type name. The plural field must be the kebab-case plural of the singular. The pattern field must match the pattern rule in the following grammar, expressed as EBNF: pattern = element, { \"/\", element }; element = variable | literal; variable = \"{\", literal, \"}\"; Where literal matches the regex [a-z][a-z0-9\\-]*[a-z0-9]. Patterns must match the possible resource paths of the resource. Pattern variables (the segments within braces) must match the singular of the resource whose id is being matched by that value. Pattern uniqueness If multiple patterns are defined within a resource, the patterns defined must not overlap in the set of resource paths that they can match. In other words, a resource path may match at most one of the patterns. For example, the following two patterns would not be valid for the same resource: user/{user} user/{user_part_1}~{user_part_2} Rationale Singular and Plural Well-defined singular and plurals of a resource enable clients to determine the proper name to use in code and documentation. google.aip.dev uses UpperCamelCase for resource types, while aep.dev uses kebab-case. This is to enforce better consistency in the representation of various multipart strings, as collection identifiers use kebab case. Changelog",
    'tags': '',
    'url': '/4',
  },
{
    'title': "Designing an API",
    'text': "Designing an API This AEP serves as a high-level guide to designing an AEP-compliant API. AEPs. Process summary Enumerate the use cases you would like your API to satisfy. Identify resources. Identify standard operations. Identify custom operations. Enumerate use cases The first step in designing an API is understanding precisely what operations you would like your user to be able to perform. Enumerate these operations, attempting to be as granular as possible. For example, if the API is for VM management in a public cloud, the operations may include: Create a VM. List all VMs owned by a company. List all VMs owned by a user. Restart a running VM. Or for a multiplayer online game, operations may include: Proposing a trade to another player. Accepting a proposed trade. Find open trade offers containing an item. List items in a player\u0027s inventory. Some best practices: Attempt to define granular use cases that can be composed to satisfy more complex use cases. Be comprehensive and consider lower-priority use cases: having more use cases enumerated often leads to better API design. Identify resources Once your use cases are defined, consider how many of those can be represented by an API Resource Type: entities that are created, read, updated, and deleted. Examples include: users virtual machines load balancers services One of the core concepts described by the AEPs is resource-oriented design: this design paradigm allows for uniform standard operations that reduce the cognitive overhead in learning about the operations and schemas exposed by your API. Resources can relate to each other. For example: A parent-child relationship defining ownership/scope (A user who created a VM). A resource dependency, where one resource depends on another to function (A VM depending on a disk). See the following AEPs to learn more about resource-oriented design: [resource-oriented design][AEP-121] [resource paths][AEP-122] [resource types][AEP-123] Identify standard operations Once the resources are defined, identify one or more standard methods for each of those resources. Standard methods operate on the lifecycle of a resource lifecycle: namely, they create, read, update, delete, and list resources. Ideally all five standard methods should be exposed for every resource. See the following AEPs to learn more about the standard methods: [AEP-131][] Identify custom operations To accomplish some of the user journeys, resources may need to support operations other than [Create][AEP-133], [Update][AEP-134], [AEP-135][Delete], [AEP-131][Get], and [AEP-132][List] them. Some examples include: restarting a virtual machine triggering a CI build wiping a disk Break down each of the actions into granular operations, then follow the custom operations AEP on how to design them.",
    'tags': '',
    'url': '/5',
  },
{
    'title': "AIP Style guide",
    'text': "AIP Style guide Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/8',
  },
{
    'title': "API Design Review FAQ",
    'text': "API Design Review FAQ Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/100',
  },
{
    'title': "Resource-oriented design",
    'text': "Resource-oriented design Resource-oriented design is a pattern for specifying RPC APIs, based on the following high-level design principles: The fundamental building blocks of an API are individually-named resources (nouns) and the relationships and hierarchy that exist between them. A small number of standard methods (verbs) provide the semantics for most common operations. However, custom methods are available in situations where the standard methods do not fit. Readers might notice similarities between these principles and some principles of REST; resource-oriented design borrows many principles from REST, while also defining its own patterns where appropriate. Guidance When designing an API, consider the following: The resources (nouns) the API will provide. The relationships and hierarchies between those resources. The schema of each resource. The methods (verbs) each resource provides, relying as much as possible on the standard verbs. Resources A resource-oriented API must be modeled as a resource hierarchy, where each node is either a simple resource or a collection of resources. A collection contains resources of the same type. For example, a publisher has the collection of books that it publishes. A resource usually has fields, and resources may have any number of sub-resources (usually collections). Note: While there is some conceptual alignment between storage systems and APIs, a service with a resource-oriented API is not necessarily a database, and has enormous flexibility in how it interprets resources and methods. API designers should not expect that their API will be reflective of their database schema. In fact, having an API that is identical to the underlying database schema is actually an anti-pattern, as it tightly couples the surface to the underlying system. Methods Resource-oriented APIs emphasize resources (data model) over the methods performed on those resources (functionality). A typical resource-oriented API exposes a large number of resources with a small number of methods on each resource. The methods can be either the standard methods (Get, List, Create, Update, Delete), or custom methods. If the request to or the response from a standard method (or a custom method in the same service) is the resource or contains the resource, the resource schema for that resource across all methods must be the same. Standard method Request Response Create Contains the resource Is the resource Get None Is the resource Update Contains the resource Is the resource Delete None None List None Is the resource The table above describes each standard method\u0027s relationship to the resource, where \"None\" indicates that the resource neither is nor is contained in the request or the response A resource must support at minimum Get: clients must be able to validate the state of resources after performing a mutation such as Create, Update, or Delete. A resource must also support List, except for singleton resources where more than one resource is not possible. Note: A custom method in resource-oriented design does not entail defining a new or custom HTTP verb. Custom methods use traditional HTTP verbs (usually POST) and define the custom verb in the URI. APIs should prefer standard methods over custom methods; the purpose of custom methods is to define functionality that does not cleanly map to any of the standard methods. Custom methods offer the same design freedom as traditional RPC APIs, which can be used to implement common programming patterns, such as database transactions, import and export, or data analysis. Strong Consistency For methods that operate on the management plane, the completion of those operations (either successful or with an error, long-running or synchronous) must mean that the state of the resource\u0027s existence and all user-settable values have reached a steady-state. Output only values unrelated to the resource state should also have reached a steady-state. Examples include: Following a successful create that is is latest mutation on a resource, a get request for a resource must return the resource. Following a successful update that is the latest mutation on a resource, a get request for a resource must return the final values from the update request. Following a successful delete that is the latest mutation on a resource, a get request for a resource must return NOT_FOUND (or the resource with the DELETED state value in the case of soft delete) Clients of resource-oriented APIs often need to orchestrate multiple operations in sequence (e.g. create resource A, create resource B which depends on A), and ensuring that resources immediately reflect steady user state after an operation is complete ensures clients can rely on method completion as a signal to begin the next operation. output only fields ideally would follow the same guidelines, but as these fields can often represent a resources live state, it\u0027s sometimes necessary for these values to change after a successful mutation operation to reflect a state change. Cyclic References The relationship between resources, such as parent-child or resource references, must be representable via a directed acyclic graph. A cyclic relationship between resources increases the complexity of managing resources. Consider resources A and B that refer to each other. The process to create said resources are: create resource A without a reference to B. Retrieve id for resource A. create resource B with a reference to A. Retrieve id for resource B. update resource A with the reference to B. The delete operation may also become more complex, due to reasoning about which resource must be dereferenced first for a successful deletion. This requirement does not apply to relationships that are expressed via output only fields, as they do not require the user to specify the values and in turn do not increase resource management complexity. Changelog 2024-01-27: From from https://google.aip.dev/121",
    'tags': '',
    'url': '/121',
  },
{
    'title': "Resource paths",
    'text': "Resource paths Most APIs expose resources (their primary nouns) which users are able to create, retrieve, and manipulate. Additionally, resources have paths: each resource has a unique (within the API service) identifying path that users use to reference that resource, and these paths are what users should store as the canonical identifier for the resources. Guidance All resource paths defined by an API must be unique within that API. (See the section on full resource paths below for more information on referring to resources across APIs.) Resource paths are formatted according to the URI path schema, but without the leading slash: publishers/123/books/les-miserables users/vhugo1802 Resource path components must alternate between collection identifiers (example: publishers, books, users) and resource IDs (example: 123, les-miserables, vhugo1802), except when singleton resources are present. Resource paths must use the / character to separate individual segments of the resource path. Each segment of a resource path must not contain a / character. Resource paths should only use characters available in DNS names, as defined by RFC-1123. Additionally, resource IDs should not use upper-case letters. If additional characters are necessary, resource paths should not use characters that require URL-escaping, or characters outside of ASCII. If Unicode characters can not be avoided, resource paths must be stored in Normalization Form C (see AEP-210). Each resource must expose a path field that contains its resource path. Resources may provide the resource ID, i.e. the last segment of the path, as a separate field named id. Resources must not expose tuples, self-links, or other forms of resource identification. All ID fields must be strings. Note: Resource paths as described here are used within the scope of a single API (or else in situations where the owning API is clear from the context), and are only required to be unique within that scope. For this reason, they are sometimes called relative resource paths to distinguish them from full resource paths (discussed below). Collection identifiers The collection identifier segments in a resource path must be the plural form of the noun used for the resource. (For example, a collection of Publisher resources is called publishers in the resource path.) Collection identifiers must be concise American English terms. Collection identifiers must be in kebab-case. Collection identifiers must begin with a lower-cased letter and contain only lower-case ASCII letters, numbers. and hyphens (/[a-z][a-z0-9-]*/). Collection identifiers must be plural. In situations where there is no plural word (\"info\"), or where the singular and plural terms are the same (\"moose\"), the non-pluralized (singular) form is correct. Collection segments must not \"coin\" words by adding \"s\" in such cases (e.g. avoid \"infos\"). Nested collections If a resource path contains multiple levels of a hierarchy, and a parent collection\u0027s path is used as a prefix for the child resource\u0027s path, the child collection\u0027s path may omit the prefix. For example, given a collection of UserEvent resources that would normally be nested underneath users: users/vhugo1802/user-events/birthday-dinner-226/user-event-guests/123 An API may use the less-redundant form: users/vhugo1802/events/birthday-dinner-226/guests/123 In this situation, the message is still called UserEvent or UserEventGuest; only the collection name is shortened. Note: APIs wishing to do this must follow this format consistently throughout the API, or else not at all. Resource ID segments A resource ID segment identifies the resource within its parent collection. In the resource path publishers/123/books/les-miserables, 123 is the resource ID for the publisher, and les-miserables is the resource ID for the book. Resource IDs may be either always set by users (required on resource creation), optionally set by users (optional on resource creation, server-generated if unset), or never set by users (not accepted at resource creation). They must be immutable once created. If resource IDs are user-settable, the API must document and/or annotate the field with the allowed formats. User-settable resource IDs should conform to RFC-1034; which restricts to letters, numbers, and hyphen, with the first character a letter, the last a letter or a number, and a 63 character maximum. Additionally, user-settable resource IDs should restrict letters to lower-case (^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$). Characters outside of ASCII should not be permitted; however, if Unicode characters are necessary, APIs must follow guidance in AEP-210. User-settable IDs should not be permitted to be a UUID (or any value that syntactically appears to be a UUID). Field annotations should use protovalidate in protobuf and JSON Schema keywords like [pattern][] with OAS/JSON Schema. If resource IDs are not user-settable, the API should document the basic format, and any upper boundaries (for example, \"at most 63 characters\"). For more information, see the create standard method. Resource ID aliases It is sometimes valuable to provide an alias for common lookup patterns for resource IDs. For example, an API with users at the top of its resource hierarchy may wish to provide users/me as a shortcut for retrieving information for the authenticated user. APIs may provide programmatic aliases for common lookup patterns. However, all data returned from the API must use the canonical resource path. Full resource paths In most cases, resource paths are used within a single API only, or else they are used in contexts where the owning API is clear (for example, string pubsub_topic). However, sometimes it is necessary for services to refer to resources in an arbitrary API. In this situation, the service should use the full resource path, a schemeless URI with the owning API\u0027s service endpoint, followed by the relative resource path: //apis.example.com/library/publishers/123/books/les-miserables //apis.example.com/calendar/users/vhugo1802 Note: The full resource path should not be used for cross-API references where the owning API is clear; it is only used if a field refers to resources in multiple APIs where ambiguity is possible. Resource URIs The full resource path is a schemeless URI, but slightly distinct from the full URIs we use to access a resource. The latter adds two components: the protocol (HTTPS) and the API version: https://apis.example.com/library/v1/publishers/123/books/les-miserables https://apis.example.com/calendar/v3/users/vhugo1802 The version is not included in the full resource path because the full resource path is expected to persist from version to version. Even though the API surface may change between major versions, multiple major versions of the same API are expected to use the same underlying data. Note: The correlation between the full resource path and the service\u0027s hostname is by convention. In particular, one service is able to have multiple hostnames (example use cases include regionalization or staging environments), and the full resource path does not change between these. Fields representing resource paths When defining a resource, the first field should be the resource path, which must be of type string and must be called path for the resource path. The message should include a google.api.resource annotation declaring the type (see AEP-123 for more on this). // A representation of a book in the library. message Book { option (google.api.resource) = { type: \"apis.example.com/library/Book\" pattern: \"publishers/{publisher}/books/{book}\" }; // The resource path of the book. // Format: publishers/{publisher}/books/{book} string path = 1; // Other fields... } When defining a method that retrieves or acts on an already-existing resource (such as GetBook or ArchiveBook), the first field of the request message should be the resource path, which must be of type string and must be called path for the resource path. The field should also be annotated with the google.api.resource_reference annotation, referencing the resource type (AEP-123). // Request message for ArchiveBook message ArchiveBookRequest { // The book to archive. // Format: publishers/{publisher}/books/{book} string path = 1 [ (google.api.field_behavior) = REQUIRED, (google.api.resource_reference) = { type: \"apis.example.com/library/Book\" }]; // Other fields... } Note: Fields must not be called path except for this purpose. For other use cases, either use a different term or prepend an adjective (for example: file_path). Fields representing a resource\u0027s parent When defining a method that retrieves resources from a collection or adds a new resource to a collection (such as ListBooks or CreateBook), the first field of the request message should be of type string and should be called parent for the resource path of the collection. The parent field should also be annotated with the google.api.resource_reference annotation, referencing the parent\u0027s resource type (AEP-123). // Request message for ListBooks. message ListBooksRequest { // The publisher to list books from. // Format: publishers/{publisher_id} string parent = 1 [(google.api.resource_reference) = { type: \"apis.example.com/library/Publisher\" }]; // Other fields (e.g. max_page_size, page_token, filter, etc.)... } If there is more than one possible parent type, the parent field should be annotated with the child_type key on google.api.resource_reference instead: // Request message for ListBooks. message ListBooksRequest { // The parent to list books from. // Format: // - publishers/{publisher_id} // - authors/{author_id} string parent = 1 [ (google.api.field_behavior) = REQUIRED, (google.api.resource_reference) = { child_type: \"apis.example.com/library/Book\" }]; // Other fields (e.g. max_page_size, page_token, filter, etc.)... } Note: Fields should not be called parent except for this purpose. For other use cases, use a synonymous term if possible. Fields representing another resource When referencing a resource path for a different resource, the field should be of type string for the resource path, and the field name should be equivalent to the corresponding message\u0027s name in snake case. Field names may include a leading adjective if appropriate (such as string dusty_book). Field names should not use the _path suffix unless the field would be ambiguous without it (e.g., crypto_key_path) Fields representing another resource should provide the google.api.resource_reference annotation with the resource type being referenced. // A representation of a book in a library. message Book { option (google.api.resource) = { type: \"apis.example.com/library/Book\" pattern: \"publishers/{publisher}/books/{book}\" }; // Path of the book. // Format is `publishers/{publisher}/books/{book}` string path = 1; // The shelf where the book currently sits. // Format is `shelves/{shelf}`. string shelf = 2 [(google.api.resource_reference) = { type: \"apis.example.com/library/Shelf\" }]; // Other fields... } Note: When referring to other resources in this way, we use the resource path as the value, not just the ID component. Services should use the resource path to reference resources when possible. If using the ID component alone is strictly necessary, the field should use an _id suffix (e.g. shelf_id). Further reading For evolving resource paths over time, see AEP-180. For resource types, see AEP-123.",
    'tags': '',
    'url': '/122',
  },
{
    'title': "Resource association",
    'text': "Resource association Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/124',
  },
{
    'title': "Enumerations",
    'text': "Enumerations It is common for a field to only accept or provide a discrete and limited set of values. In these cases, it can be useful to use enumerations (generally abbreviated \"enums\") in order to clearly communicate what the set of allowed values are. Guidance APIs may expose enum objects for sets of values that are expected to change infrequently: // Possible formats in which a book may be published. enum Format { // The printed format, in hardback. Hardback = \u0027HARDBACK\u0027, // The printed format, in paperback. Paperback = \u0027PAPERBACK\u0027, // An electronic book format. Ebook = \u0027EBOOK\u0027, // An audio recording. Audiobook = \u0027AUDIOBOOK\u0027, } All enum values should use a consistent case format across an organization. In many cases, this is dictated by the IDL the organization uses. Enums should document whether the enum is frozen or they expect to add values in the future. When to use enums Enums can be more accessible and readable than strings or booleans in many cases, but they do add overhead when they change. Therefore, enums should receive new values infrequently. While the definition of \"infrequently\" may change based on individual use cases, a good rule of thumb is no more than once a year. For enums that change frequently, the API should use a string and document the format. Note: If an enumerated value needs to be shared across APIs, an enum may be used, but the assignment between enum values and their wire representation must match. Alternatives Enums should not be used when there is a competing, widely-adopted standard representation (such as with language codes or media types). Instead, that standard representation should be used. This is true even if only a small subset of values are permitted, because using enums in this situation often leads to frustrating lookup tables when trying to use multiple APIs together. For enumerated values where the set of allowed values changes frequently, APIs should use a string field instead, and must document the allowed values. String fields with enumerated values should use a uniform case system (snake_case, kebab-case, etc.) throughout an organization. Boolean fields may be used in situations where it is clear that no further flexibility will be needed. The default value must be false. Compatibility Adding values to an enum has the potential to be disruptive to existing clients. Consider code written against the Format enum in an earlier version where only the first two options were available: switch (book.format) { case Format.Hardback: // Do something... break; case Format.Paperback: // Do something... break; default: // When new enum values are introduced, pre-existing client code may // throw errors or act in unexpected ways. throw new Error(\u0027Unrecognized value.\u0027); } Services may add new values to existing enums; however, they should add enums carefully; think about what will happen if a client system does not know about a new value. Additionally, in IDLs where enum values are presented in a specific order, services should only add new values to the end. An exception to this rule is if the enum conforms to an external standard (for example, an enum representing HTTP status codes would add a new 3xx value alongside the others, not at the end). Interface Definitions Protocol buffers // Possible formats in which the book may be published. enum Format { // Default value. This value is unused. FORMAT_UNSPECIFIED = 0; // The printed format, in hardback. HARDBACK = 1; // The printed format, in paperback. PAPERBACK = 2; // An electronic book format. EBOOK = 3; // An audio recording. AUDIOBOOK = 4; } The zero value of the enum should be the name of the enum itself followed by the suffix _UNSPECIFIED. The service may either allow or prohibit use of this value. Enums which will only be used in a single message should be nested within that message. In this case, the enum should be declared immediately before it is used. If multiple enums are in the same namespace, they must not share any values. (This is because enums do not provide their own namespace for their values in some languages.) If an enumerated value needs to be shared across APIs, an enum may be used, but the assignment between the value names and the tag numbers must match. Note: When using protocol buffers, it is impossible to distinguish between false and unset. If this is a requirement, an enum may be a better design choice (although google.protobuf.BoolValue is also available). OpenAPI 3.0 format: type: string description: The format of the book. nullable: true enum: - null - HARDCOVER - PAPERBACK - EBOOK - AUDIOBOOK Enumerated fields should be strings. If the enum is optional, The null value should be used as the empty value, and should be the first value specified. Note: If null is a valid value, OpenAPI 3.0 also requires that nullable: true is specified for the field. Further reading For states, a special type of enum, see AEP-216.",
    'tags': '',
    'url': '/126',
  },
{
    'title': "HTTP and gRPC Transcoding",
    'text': "HTTP and gRPC Transcoding Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/127',
  },
{
    'title': "Get",
    'text': "Get In REST APIs, it is customary to make a GET request to a resource\u0027s URI (for example, /v1/publishers/{publisher}/books/{book}) in order to retrieve that resource. Resource-oriented design (AEP-121) honors this pattern through the Get method. These RPCs accept the URI representing that resource and return the resource. Guidance APIs must provide a get method for resources. The purpose of the get method is to return data from a single resource. Requests Get operations must be made by sending a GET request to the resource\u0027s URI: GET /v1/publishers/{publisher}/books/{book} HTTP/2 Host: library.example.com Accept: application/json The HTTP method must be GET. The request must be safe and must not have side effects. There must not be a request body. If a GET request contains a body, the body must be ignored, and must not cause an error. The request must not require any fields in the query string. The request should not include optional fields in the query string unless described in another AEP. Responses Single-resource GET operations must return the resource itself, without any additional wrapping: { \"name\": \"publishers/lacroix/books/les-mis\", \"isbn\": \"978-037-540317-0\", \"title\": \"Les Mis\u00e9rables\", \"authors\": [\"Victor Hugo\"], \"rating\": 9.6 } The response should usually include the fully-populated resource unless there is a reason to return a partial response (see AEP-157). Errors If the user does not have sufficient permission to know that the resource exists, the service should reply with an HTTP 404 error, regardless of whether or not the resource exists. Permission must be checked prior to checking if the resource exists. If the user has sufficient permission to know that the resource exists, but is unable to access it, the service should reply with an HTTP 403 error. If the user does have proper permission, but the requested resource does not exist, the service must reply with an HTTP 404 error. Interface Definitions Protocol buffers Get operations are specified using the following pattern: // Get a single book. rpc GetBook(GetBookRequest) returns (Book) { option (google.api.http) = { get: \"/v1/{path=publishers/*/books/*}\" }; option (google.api.method_signature) = \"path\"; } The RPC\u0027s name must begin with the word Get. The remainder of the RPC name should be the singular form of the resource\u0027s message name. The request message must match the RPC name, with a Request suffix. The response message must be the resource itself. (There is no GetBookResponse.) The HTTP verb must be GET. The URI should contain a single variable field corresponding to the resource path. This field should be called path. The URI should have a variable corresponding to this field. The path field should be the only variable in the URI path. All remaining parameters should map to URI query parameters. There must not be a body key in the google.api.http annotation. There should be exactly one google.api.method_signature annotation, with a value of \"path\". Get operations also implement a common request message pattern: // Request message to get a single book. message GetBookRequest { // The path of the book to retrieve. string path = 1 [ (google.api.field_behavior) = REQUIRED, (google.api.resource_reference) = { type: \"library.googleapis.com/Book\" }]; } A resource path field must be included. It should be called path. The field should be annotated as REQUIRED. The field should identify the resource type that it references. The comment for the path field should document the resource pattern. The request message must not contain any other required fields, and should not contain other optional fields except those described in another AEP. Note: The path field in the request object corresponds to the path variable in the google.api.http annotation on the RPC. This causes the path field in the request to be populated based on the value in the URL when the REST/JSON interface is used. OpenAPI 3.0 Single-resource GET operations must be specified with consistent OpenAPI metadata: paths: /publishers/{publisherId}/books/{bookId}: get: operationId: getBook description: Get a single book. responses: 200: description: OK content: application/json: schema: $ref: \u0027#/components/schemas/Book\u0027 The operationId must begin with the word get. The remainder of the operationId should be the singular form of the resource type\u0027s name. The response content must be the resource itself. For example: #/components/schemas/Book The URI should contain a variable for each individual ID in the resource hierarchy. The path parameter for all resource IDs must be in the form {resourceName}Id (such as bookId), and path parameters representing the ID of parent resources must end with Id.",
    'tags': '',
    'url': '/131',
  },
{
    'title': "List",
    'text': "List In REST APIs, it is customary to make a GET request to a resource collection\u0027s URI (for example, /v1/publishers/{publisher}/books) in order to retrieve a list of the resources within that collection. Resource-oriented design (AEP-121) honors this pattern through the List method. These RPCs accept the parent collection (and potentially some other parameters), and return a list of responses matching that input. Guidance APIs should provide a List method for resource collections.The purpose of the List method is to return data from a finite collection (generally singular unless the operation supports reading across collections). When the GET method is used on a URI ending in a resource collection, the result must be a list of resources. Requests List operations must be made by sending a GET request to the resource collection\u0027s URI: GET /v1/publishers/{publisher}/books HTTP/2 Host: library.googleapis.com Accept: application/json The HTTP method must be GET. The request must be safe and must not have side effects. There must not be a request body. If a GET request contains a body, the body must be ignored, and must not cause an error. The request must not require any fields in the query string. The query string may include fields for common design patterns relevant to list methods, such as string filter and string orderBy. The query string may include custom fields if necessary for a specific resource, but not in place of any of the common fields for list methods. Responses List operations must return a page of results, with each individual result being a resource: { \"results\": [ { \"name\": \"publishers/lacroix/books/les-mis\", \"isbn\": \"978-037-540317-0\", \"title\": \"Les Mis\u00e9rables\", \"authors\": [\"Victor Hugo\"], \"rating\": 9.6 }, { \"name\": \"publishers/lacroix/books/hunchback-of-notre-dame\", \"isbn\": \"978-140-274575-1\", \"title\": \"The Hunchback of Notre Dame\", \"authors\": [\"Victor Hugo\"], \"rating\": 9.3 } ], \"nextPageToken\": \"xyz\" } The array of resources must be named results and contain resources with no additional wrapping. The string nextPageToken field must be included in the list response schema. It must be set if there are subsequent pages, and must not be set if the response represents the final page. For more information, see AEP-158. The response struct may include a int32 totalSize (or int64 totalSize) field with the number of items in the collection. The value may be an estimate (the field should clearly document this if so). If filtering is used, the totalSize field should reflect the size of the collection after the filter is applied. Note: List methods may return the complete collection to any user with permission to make a successful List request on the collection, or may return a collection only containing resources for which the user has read permission. This behavior should be clearly documented either for each List method or as a standard convention in service-level documentation. Permission checks on individual resources may have a negative performance impact so should be used only where absolutely necessary. Errors If the user does not have sufficient permission to know that the collection exists, the service should reply with an HTTP 404 error, regardless of whether or not the collection exists. Permission must be checked prior to checking whether the collection exists. If the user does have proper permission, but the requested collection does not exist (generally because the parent does not exist), the service must reply with an HTTP 404 error. Note: An empty collection which the user has permission to access must return 200 OK with an empty results array, and not 404 Not Found. Ordering List methods may allow clients to specify sorting order; if they do, the request message should contain a string orderBy field. Values should be a comma separated list of fields. For example: \"foo,bar\". The default sorting order is ascending. To specify descending order for a field, users append a - prefix; for example: \"foo,-bar\", \"-foo,bar\". Redundant space characters in the syntax are insignificant. \"foo, -bar\", \" foo , -bar \", and \"foo,-bar\" are all equivalent. Subfields are specified with a . character, such as foo.bar or address.street. Note: Only include ordering if there is an established need to do so. It is always possible to add ordering later, but removing it is a breaking change. Filtering List methods may allow clients to specify filters; if they do, the request message should contain a string filter field. Filtering is described in more detail in AEP-160. Note: Only include filtering if there is an established need to do so. It is always possible to add filtering later, but removing it is a breaking change. Soft-deleted resources Some APIs need to \"soft-delete\" resources, marking them as deleted or pending deletion (and optionally purging them later). APIs that do this should not include deleted resources by default in list requests. APIs with soft deletion of a resource should include a bool showDeleted field in the list request that, if set, will cause soft-deleted resources to be included. Interface Definitions Protocol buffers List operations are specified using the following pattern: // Get a single book. rpc ListBooks(ListBooksRequest) returns (ListBooksResponse) { option (google.api.http) = { get: \"/v1/{parent=publishers/*}/books\" }; option (google.api.method_signature) = \"parent\"; } The RPC\u0027s name must begin with the word List. The remainder of the RPC name should be the plural form of the resource\u0027s message name. The request message must match the RPC name, with a -Request suffix. The response message must match the RPC name, with a -Response suffix. The response should usually include fully-populated resources unless there is a reason to return a partial response (see AEP-157). The HTTP verb must be GET. The URI should contain a single variable field corresponding to the collection parent\u0027s name. This field should be called parent. The URI should have a variable corresponding to this field. The parent field should be the only variable in the URI path. All remaining parameters should map to URI query parameters. There must not be a body key in the google.api.http annotation. There should be exactly one google.api.method_signature annotation, with a value of \"parent\". List operations also implement a common request message pattern: // Request message to list a collection of books. message ListBooksRequest { // The publisher to list books for. string parent = 1 [ (google.api.field_behavior) = REQUIRED, (google.api.resource_reference) = { child_type: \"library.googleapis.com/Book\" }]; // The maximum number of books to return. // The service may send fewer. int32 max_page_size = 2; // The page token. // If a `next_page_token` value was received on a previous // ListBooks call, providing it here will return the next page. string page_token = 3; } A parent field must be included unless the resource being listed is a top-level resource. It should be called parent. The field must be annotated as required. The field must identify the resource type of the resource being listed with a google.api.resource_reference annotation. The max_page_size and page_token fields, which support pagination, must be specified on all list request messages. For more information, see AEP-158. Note: The parent field in the request object corresponds to the parent variable in the google.api.http annotation on the RPC. This causes the parent field in the request to be populated based on the value in the URL when the REST/JSON interface is used. // Response message for listing a collection of books. message ListBooksResponse { // The books under the umbrella of the given publisher. repeated Book results = 1; // The token to retrieve the next page. This is populated if and only if // there are more pages. string next_page_token = 2; } The response message must include a field corresponding to the resources being returned, named for the English plural term for the resource, and should not include any other repeated fields. Fields providing metadata about the list request (such as string next_page_token or int32 total_size) must be included on the response message (not as part of the resource itself). OpenAPI 3.0 List operations must be specified with consistent OpenAPI metadata: paths: /publishers/{publisherId}/books: parameters: - name: publisherId in: path description: The publisher to list books for. required: true schema: type: string get: operationId: listBooks description: Get a collection of books. parameters: - name: pageToken in: query description: | The page token. If a `next_page_token` value was received on a previous ListBooks call, providing it here will return the next page. schema: type: string - name: maxPageSize in: query description: | The maximum number of books to return. schema: type: integer responses: \u0027200\u0027: description: OK content: application/json: schema: $ref: \u0027#/components/schemas/ListBooksResponse\u0027 The operationId must begin with the word list. The remainder of the operationId should be the plural form of the resource type\u0027s name. The response content must be the resource itself. For example: #/components/schemas/Book The response should usually include the fully-populated resource unless there is a reason to return a partial response (see AEP-157). The URI should contain a variable for each individual ID in the resource hierarchy. The path parameter for all resource IDs must be in the form {resourceName}Id (such as bookId), and path parameters representing the ID of parent resources must end with Id.",
    'tags': '',
    'url': '/132',
  },
{
    'title': "Create",
    'text': "Create Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/133',
  },
{
    'title': "Update",
    'text': "Update Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/134',
  },
{
    'title': "Delete",
    'text': "Delete Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/135',
  },
{
    'title': "Custom operations",
    'text': "Custom operations Services use custom operations to provide a means to express arbitrary actions that are difficult to model using only the standard operations. Custom operations are important because they provide a means for an API\u0027s vocabulary to adhere to user intent. Guidance Custom operations should only be used for functionality that can not be easily expressed via standard operations; prefer standard operations if possible, due to their consistent semantics. (Of course, this only applies if the functionality in question actually conforms to the normal semantics; it is not a good idea to contort things to endeavor to make the standard operations \"sort of work\".) While custom operations vary widely in how they are designed, many principles apply consistently: Protocol buffers // Archives the given book. rpc ArchiveBook(ArchiveBookRequest) returns (ArchiveBookResponse) { option (google.api.http) = { post: \"/v1/{name=publishers/*/books/*}:archive\" body: \"*\" }; } The name of the RPC should be a verb followed by a noun. The name must not contain prepositions (\"for\", \"with\", etc.). The HTTP method for custom operations should usually be POST, unless the custom method maps more strongly to another HTTP verb. Custom operations that serve as an alternative to get or list operations (such as Search) should use GET. These operations must be idempotent and have no state changes or side effects (they should be safe as defined in RFC 7231). Custom operations should not use PATCH or DELETE. The HTTP URI must use a : character followed by the custom verb (:archive in the above example), and the verb in the URI must match the verb in the name of the RPC. If word separation is required, camelCase must be used. The body clause in the google.api.http annotation should be \"*\". However, if using GET or DELETE, the body clause must be absent. Custom operations should usually take a request message matching the RPC name, with a -Request suffix. Custom operations should usually return a response message matching the RPC name, with a -Response suffix. When operating on a specific resource, a custom method may return the resource itself. OpenAPI 3.0 /publishers/{publisherId}/books/{bookId}:archive: post: operationId: archiveBook description: Archives the given book. requestBody: description: content: application/json: schema: description: Request structure to archive a book. properties: mime_type: type: string description: | The target format for the archived book. Must be \"application/pdf\", \"application/rtf\", or \"application/epub+zip\" required: true enum: - application/pdf - application/rtf - application/epub+zip responses: 200: description: OK content: application/json: schema: description: Response structure for the archiveBook operation. properties: uri: type: string description: The location of the archived book. The operationId should be a verb followed by a noun. The operationId must not contain prepositions (\"for\", \"with\", etc.). The HTTP method for custom operations should usually be POST, unless the custom method maps more strongly to another HTTP verb. Custom operations that serve as an alternative to get or list operations (such as Search) should use GET, and require no request body. These operations must be idempotent and have no state changes or side effects (they should be safe as defined in RFC 7231). Custom operations should not use PATCH or DELETE. The HTTP URI must use a : character followed by the custom verb (:archive in the above example), and the verb in the URI must match the verb in the operationId. If word separation is required, camelCase must be used. Note: The pattern above shows a custom method that operates on a specific resource. Custom operations can be associated with resources, collections, or services. Collection-based custom operations While most custom operations operate on a single resource, some custom operations may operate on a collection instead: Protocol buffers // Sorts the books from this publisher. rpc SortBooks(SortBooksRequest) returns (SortBooksResponse) { option (google.api.http) = { post: \"/v1/{publisher=publishers/*}/books:sort\" body: \"*\" }; } OpenAPI 3.0 /publishers/{publisherId}/books:sort: post: operationId: sortBooks description: Sorts the books from this publisher. requestBody: description: Request structure to sort a collection of books. properties: field: type: string description: | The property of the book to sort by. If not provided, \"title\" is used. responses: 200: description: OK If the collection has a parent, the field name in the request message should be the target resource\u0027s singular noun (publisher in the above example). If word separators are necessary, snake_case must be used. The collection key (books in the above example) must be literal. Stateless operations Some custom operations are not attached to resources at all. These operations are generally stateless: they accept a request and return a response, and have no permanent effect on data within the API. Protocol buffers // Translates the provided text from one language to another. rpc TranslateText(TranslateTextRequest) returns (TranslateTextResponse) { option (google.api.http) = { post: \"/v1/{project=projects/*}:translateText\" body: \"*\" }; } OpenAPI 3.0 /projects/{projectId}:translateText: post: operationId: translateText description: Translates the provided text from one language to another. requestBody: description: content: application/json: schema: description: Request structure to translate text. properties: contents: type: array items: type: string description: The contents of the input, as a string. source_language_code: type: string description: | The BCP-47 language code of the input text (e.g. \"en-US\"). If the source language is not specified, the service will attempt to infer it. target_language_code: type: string description: | The BCP-47 language code of the output text (e.g. \"en-US\"). responses: 200: description: OK content: application/json: schema: description: | Response structure for the translateText operation. properties: translated_text: type: string description: | Text translated into the target language. detected_language_code: type: string description: | The BCP-47 language code of source text in the initial request, if it was detected automatically. If the method runs in a particular scope (such as a project, as in the above example), the field name in the request message should be the name of the scope resource. If word separators are necessary, snake_case must be used. The URI should place both the verb and noun after the : separator (avoid a \"faux collection key\" in the URI in this case, as there is no collection). For example, :translateText is preferable to text:translate. Stateless operations must use POST if they involve billing. Declarative-friendly resources Declarative-friendly resources usually should not employ custom operations (except specific declarative-friendly custom operations discussed in other AEPs), because declarative-friendly tools are unable to automatically determine what to do with them. An exception to this is for rarely-used, fundamentally imperative operations, such as a Move, Rename, or Restart operation, for which there would not be an expectation of declarative support.",
    'tags': '',
    'url': '/136',
  },
{
    'title': "Field names",
    'text': "Field names Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/140',
  },
{
    'title': "Quantities",
    'text': "Quantities Many services need to represent a discrete quantity of items (number of bytes, number of miles, number of nodes, etc.). Guidance Quantities with a clear unit of measurement (such as bytes, miles, and so on) must include the unit of measurement as the suffix. When appropriate and unambiguous, units should use generally accepted abbreviations (for example, distance_km rather than distance_kilometers). // A representation of a non-stop air route. interface Route { // The airport where the route begins. origin: string; // The destination airport. destination: string; // The distance between the origin and destination airports. // This value is also used to determine the credited frequent flyer miles. distance_miles: number; } If the quantity is a number of items (for example, the number of nodes in a cluster), then the field should use the suffix _count (not the prefix num_): // A cluster of individual nodes. interface Cluster { // The number of nodes in the cluster. node_count: number; } Note: Fields must not use unsigned integer types, because many programming languages and systems do not support them well. Specialized messages It is sometimes useful to create a message that represents a particular quantity. This is particularly valuable in two situations. Grouping two or more individual quantities together. Representing a common concept where the unit of measurement may itself vary. Consider the example of money, which could need to do both of these: // A representation of an amount of money, in an arbitrary currency. interface Money { // The 3-letter currency code defined in ISO 4217. currency_code: string; // The whole units of the amount. // For example if `currency_code` is \"USD\", then 1 unit is one US dollar. units: bigint; // Number of nano (10^-9) units of the amount. // The value must be between -999,999,999 and +999,999,999 inclusive. // If `units` is positive, `nanos` must be positive or zero. // If `units` is zero, `nanos` can be positive, zero, or negative. // If `units` is negative, `nanos` must be negative or zero. // For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000. nanos: number; } APIs may create structs to represent quantities when appropriate. When using these structs as fields, APIs should use the name of the struct as the suffix for the field name if it makes intuitive sense to do so. Changelog 2019-09-13: Added the prohibition on unsigned types.",
    'tags': '',
    'url': '/141',
  },
{
    'title': "Time and duration",
    'text': "Time and duration Many services need to represent the concepts surrounding time. Representing time can be challenging due to the intricacies of calendars and time zones, as well as the fact that common exchange formats (such as JSON) lack a native concept of time. Guidance Fields representing time should use a string field with values conforming to RFC 3339, such as 2012-04-21T15:00:00Z. Services should use IDL-specific timestamps or format indicators where applicable (such as google.protobuf.Timestamp in protocol buffers, or format: date-time in OpenAPI) provided that the service converts values to RFC 3339 timestamp strings in JSON. Timestamps Fields that represent an absolute point in time (independent of any time zone or calendar) should use a string field with RFC 3339 values, and should send values in UTC, with the Z time zone explicitly included. These fields should have names ending in _time, such as create_time or update_time. For array fields, the names should end in _times instead. Many timestamp fields refer to an activity (for example, create_time refers to when the applicable resource was created). For these, the field should be named with the {root_word}_time form. For example, if a book is being published, the field storing the time when this happens would use the root form of the verb \"to publish\" (\"publish\"), resulting in a field called publish_time. Fields should not be named using the past tense (such as published_time, created_time or last_updated_time). When accepting timestamps as input, services should canonicalize the timestamp into UTC, and return values in UTC. Durations Fields that represent a span between two points in time (independent of any time zone or calendar) should use an int field if there is a single canonical unit (for example, ttl_seconds for an expiring resource, or offset_seconds for position in a video). Note: A float field may be used if fractional seconds are needed. However, only fractional seconds are permitted; other fractional units (such as hours or days) must not be used. If there is no canonical unit, the service should use a string field with ISO 8601 duration values, such as P3Y6M4DT12H30M5S. The field name should end with _duration. Designators for zero values may be omitted in accordance with ISO 8601 (for example: PT12H is sufficient to represent \"12 hours\"), but at least one designator must be present (therefore, a zero duration is PT0S or P0D). Services should use IDL-specific durations where applicable (such as google.protobuf.Duration in protocol buffers) provided that the service converts values to ISO 8601 duration strings in JSON. Fractional seconds Services may support fractional seconds for both timestamps and durations, but should not support precision more granular than the nanosecond. Services may also limit the supported precision, and may truncate values received from the user to the supported precision. Note: Truncation is recommended rather than rounding because rounding to the nearest second has the potential to change day, month, year, etc., which is surprisingly significant. Civil dates and times Fields that represent a calendar date or wall-clock time should use partial ISO 8601 strings. Fields representing civil dates should have names ending in _date, while fields representing civil times or datetimes should have names ending in _time. Recurring time A service that needs to document a recurring event should use cronspec if cronspec is able to support the service\u0027s use case. Compatibility Occasionally, APIs are unable to use RFC 3339 strings for legacy or compatibility reasons. For example, an API may conform to a separate specification that mandates that timestamps be Unix timestamp integers. In these situations, fields may use other types. If possible, the following naming conventions apply: Unix timestamps should use a unix_time suffix. Multipliers of Unix time (such as milliseconds) should not be used; if they are unavoidable, the field name should use both unix_time and the unit, such as unix_time_millis. For other integers, include the meaning (examples: time, duration, delay, latency) and the unit of measurement (valid values: seconds, millis, micros, nanos) as a final suffix. For example, send_time_millis. For strings, include the meaning (examples: time, duration, delay, latency) but no unit suffix. In all cases, clearly document the expected format, and the rationale for its use.",
    'tags': '',
    'url': '/142',
  },
{
    'title': "Standardized codes",
    'text': "Standardized codes Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/143',
  },
{
    'title': "Array fields",
    'text': "Array fields Representing lists of data in an API is trickier than it often appears. Users often need to modify lists in place, and longer data series within a single resource pose a challenge for pagination. Guidance Resources may use array fields where appropriate. interface Book { // The resource name for the book. name: string; // The authors of the book. authors: string[]; } Array fields must use a plural field name. If the English singular and plural words are identical (\"moose\", \"info\"), the dictionary word must be used rather than attempting to coin a new plural form. Array fields should have an enforced upper bound that will not cause a single resource payload to become too large. A good rule of thumb is 100 elements. If an array data can not be bounded (in other words, if there is a chance that the array will be too large to be reasonably returned in a single request), the API should use a sub-resource instead. Array fields must not represent the body of another resource inline. Instead, the field should be a array of strings providing the resource names of the associated resources. Note: This document uses the term \"array\" to refer to a field on a resource that is a list of elements that have the same type. Some languages and IDLs use other terms, such as \"list\", \"repeated\", or \"sequence\", and these terms are all synonymous for the purposes of this document. The term \"collection\" is distinct, and refers to a group of resources under a single parent rather than a field on a resource. Scalars and structs Array fields should use a scalar type (such as string) if they are certain that additional data will not be needed in the future, as using a struct type adds significant cognitive overhead and leads to more complicated code. However, if additional data is likely to be needed in the future, array fields should use a struct instead of a scalar proactively, to avoid parallel array fields. Update strategies A resource may use one of two strategies to enable updating a array field: direct update using the [standard Update][aip-134] method, or custom Add and Remove methods. A standard Update method has one key limitation: the user is only able to update the entire array. This means that the user is required to read the resource, make modifications to the array field value as needed, and send it back. This is fine for many situations, particularly when the array field is expected to have a small size (fewer than 10 or so) and race conditions are not an issue, or can be guarded against with [ETags][aip-154]. Note: Declarative-friendly resources (AEP-128) must use the standard Update method, and not introduce Add and Remove methods. If declarative tools need to reason about particular relationships while ignoring others, consider using a subresource instead. If atomic modifications are required, and if the array is functionally a set (meaning that order does not matter, duplicate values are not meaningful, and non-comparable values such as null or NaN are not used), the API should define custom methods using the verbs Add and Remove: Protocol buffers // Add an author to a book. rpc AddAuthor(AddAuthorRequest) returns (Book) { option (google.api.http) = { post: \"/v1/{book=publishers/*/books/*}:addAuthor\" body: \"*\" }; } // Remove an author from a book. rpc RemoveAuthor(RemoveAuthorRequest) returns (Book) { option (google.api.http) = { post: \"/v1/{book=publishers/*/books/*}:removeAuthor\" body: \"*\" }; } The data being added or removed should be a primitive (usually a string). For more complex data structures with a primary key, the API should use a map with the Update method instead. The RPC\u0027s name must begin with the word Add or Remove. The remainder of the RPC name should be the singular form of the field being added. The response should be the resource itself, and should fully-populate the resource structure. The HTTP method must be POST, as usual for [custom methods][aip-136]. The HTTP URI must end with :add* or :remove*, where * is the camel-case singular name of the field being added or removed. The request field receiving the resource name should map to the URI path. The HTTP variable should be the name of the resource (such as book) rather than name or parent. That variable should be the only variable in the URI path. The body clause in the google.api.http annotation should be \"*\". If the data being added in an Add operation is already present, the method should accept the request and make no changes (no-op), but may error with ALREADY_EXISTS if appropriate. If the data being removed in a Remove operation is not present, the method should accept the request and make no changes (no-op), but may error with NOT_FOUND if appropriate. OpenAPI 3.0 paths: \u0027/publishers/{publisherId}/books/{bookId}:addAuthor\u0027: post: operationId: addAuthor description: Add an author to a book. requestBody: content: application/json: schema: properties: author: type: string description: The author to be added. required: true required: true responses: 200: description: OK content: application/json: schema: $ref: \u0027#/components/schemas/Book\u0027 \u0027/publishers/{publisherId}/books/{bookId}:removeAuthor\u0027: post: operationId: removeAuthor description: Remove an author from a book. requestBody: content: application/json: schema: properties: author: type: string description: The author to be removed. required: true required: true responses: 200: description: OK content: application/json: schema: $ref: \u0027#/components/schemas/Book\u0027 The data being added or removed should be a primitive (usually a string). For more complex data structures with a primary key, the API should use a map with the Update method instead. The operationId must begin with the word add or remove. The remainder of the operationId should be the singular form of the field being added. The response should be the resource itself, and should fully-populate the resource structure. The HTTP method must be POST, as usual for [custom methods][aip-136]. The HTTP URI must end with :add* or :remove*, where * is the camel-case singular name of the field being added or removed. If the data being added in an Add operation is already present, the method should accept the request and make no changes (no-op), but may error with 409 Conflict if appropriate. If the data being removed in a Remove operation is not present, the method should accept the request and make no changes (no-op), but may error with 404 Not Found if appropriate. Note: If both of these strategies are too restrictive, consider using a subresource instead. Request Structure Protocol buffers // The request structure for the AddAuthor operation. message AddAuthorRequest { // The name of the book to add an author to. string book = 1 [ (google.api.field_behavior) = REQUIRED, (google.api.resource_reference).type = \"library.googleapis.com/Book\" ]; // The author to be added. string author = 2 [(google.api.field_behavior) = REQUIRED]; } // The request structure for the RemoveAuthor operation. message RemoveAuthorRequest { // The name of the book to remove an author from. string book = 1 [ (google.api.field_behavior) = REQUIRED, (google.api.resource_reference).type = \"library.googleapis.com/Book\" ]; // The author to be removed. string author = 2 [(google.api.field_behavior) = REQUIRED]; } A resource field must be included. It should be the name of the resource (such as book) rather than name or parent. The field should be [annotated as required][aip-203]. If the field represents the name of another resource, it should identify the [resource type][aip-123] that it references. A field for the value being added or removed must be included. It should be the singular name of the field. The field should be [annotated as required][aip-203]. The request message must not contain any other required fields, and should not contain other optional fields except those described in this or another AEP. OpenAPI 3.0 requestBody: content: application/json: schema: properties: author: type: string description: The author to be added. required: true required: true A field for the value being added or removed must be included. It should be the singular name of the field. The field should be designated as required.",
    'tags': '',
    'url': '/144',
  },
{
    'title': "Ranges",
    'text': "Ranges Services often need to represent ranges of discrete or continuous values. These have wide differences in meaning, and come in many types: integers, floats, and timestamps, just to name a few, and the expected meaning of a range can vary in subtle ways depending on the type of range being discussed. Guidance A resource or message representing a range should ordinarily use two separate fields of the same type, with prefixes start_ and end_: // A representation of a chapter in a book. interface Chapter { title: string; // The page where this chapter begins. startPage: number; // The page where the next chapter or section begins. endPage: number; } Inclusive or exclusive ranges Fields representing ranges should use inclusive start values and exclusive end values (half-closed intervals) in most situations; in interval notation: [start_xxx, end_xxx). Exclusive end values are preferable for the following reasons: It conforms to user expectations, particularly for continuous values such as timestamps, and avoids the need to express imprecise \"limit values\" (e.g. 2012-04-20T23:59:59). It is consistent with most common programming languages, including C++, Java, Python, and Go. It is easier to reason about abutting ranges: [0, x), [x, y), [y, z), where values are chainable from one range to the next. Exceptions In some cases, there is significant colloquial precedent for inclusive start and end values (closed intervals), to the point that using an exclusive end value would be confusing even for people accustomed to them. For example, when discussing dates (not to be confused with timestamps), most people use inclusive end: a conference with dates \"April 21-23\" is expected to run for three days: April 21, April 22, and April 23. This is also true for days of the week: a business that is open \"Monday through Friday\" is open, not closed, on Fridays. In this situation, the prefixes first and last should be used instead: // A representation of a chapter in a book. interface Chapter { title: string; // The first page of the chapter. firstPage: number; // The last page of the chapter. lastPage: number; } Fields representing ranges with significant colloquial precedent for inclusive start and end values should use inclusive end values with first_ and last_ prefixes for those ranges only. The service should still use exclusive end values for other ranges where this does not apply, and must clearly document each range as inclusive or exclusive.",
    'tags': '',
    'url': '/145',
  },
{
    'title': "Generic fields",
    'text': "Generic fields Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/146',
  },
{
    'title': "Standard fields",
    'text': "Standard fields Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/148',
  },
{
    'title': "Long-running operations",
    'text': "Long-running operations Occasionally, a service may need to expose an operation that takes a significant amount of time to complete. In these situations, it is often a poor user experience to simply block while the task runs; rather, it is better to return some kind of promise to the user, and allow the user to check back in later. The long-running request pattern is roughly analogous to a Future in Python or Java, or a Node.js Promise. Essentially, the user is given a token that can be used to track progress and retrieve the result. Guidance Operations that might take a significant amount of time to complete should return a 202 Accepted response along with an Operation resource that can be used to track the status of the request and ultimately retrieve the result. Any single operation defined in an API surface must either always return 202 Accepted along with an Operation, or never do so. A service must not return a 200 OK response with the result if it is \"fast enough\", and 202 Accepted if it is not fast enough, because such behavior adds significant burdens for clients. Note: User expectations can vary on what is considered \"a significant amount of time\" depending on what work is being done. A good rule of thumb is 10 seconds. Operation representation The response to a long-running request must be an [Operation][]. Protocol buffers Protocol buffer APIs must use the common component [aep.api.Operation][]. OpenAPI 3.0 OpenAPI services must use this [JSON Schema Operation][] schema. Querying an operation The service must provide an endpoint to query the status of the operation, which must accept the operation path and should not include other parameters: GET /v1/operations/{operation} HTTP/2 Host: library.example.com Accept: application/json The endpoint must return a Operation as described above. Standard methods APIs may return an Operation from the [Create][aip-133], [Update][aip-134], or [Delete][aip-135] standard methods if appropriate. In this case, the response field must be the standard and expected response type for that standard method. When creating or deleting a resource with a long-running request, the resource should be included in [List][aip-132] and [Get][aip-131] calls; however, the resource should indicate that it is not usable, generally with a [state enum][aip-216]. Parallel requests A resource may accept multiple requests that will work on it in parallel, but is not obligated to do so: Resources that accept multiple parallel requests may place them in a queue rather than work on the requests simultaneously. Resource that does not permit multiple requests in parallel (denying any new request until the one that is in progress finishes) must return 409 Conflict if a user attempts a parallel request, and include an error message explaining the situation. Expiration APIs may allow their operation resources to expire after sufficient time has elapsed after the request completed. Note: A good rule of thumb for operation expiry is 30 days. Errors Errors that prevent a long-running request from starting must return an error response (AEP-193), similar to any other method. Errors that occur over the course of a request may be placed in the metadata message. The errors themselves must still be represented with a canonical error object. Interface Definitions Protocol buffers When using protocol buffers, the common component [aep.api.Operation][] is used. // Write a book. rpc WriteBook(WriteBookRequest) returns (aep.api.Operation) { option (google.api.http) = { post: \"/v1/{parent=publishers/*}/books:write\" body: \"*\" }; option (aep.api.operation_info) = { response_type: \"WriteBookResponse\" metadata_type: \"WriteBookMetadata\" }; } The response type must be aep.api.Operation. The Operation proto definition should not be copied into individual APIs; prefer to use a single copy (in monorepo code bases), or remote dependencies via a tool like [Buf][buf.build]. The response must not be a streaming response. The method must include a aep.api.operation_info annotation, which must define both response and metadata types. The response and metadata types must be defined in the file where the RPC appears, or a file imported by that file. If the response and metadata types are defined in another package, the fully-qualified message name must be used. The response type should not be google.protobuf.Empty (except for [Delete][aip-135] methods), unless it is certain that response data will never be needed. If response data might be added in the future, define an empty message for the RPC response and use that. The metadata type is used to provide information such as progress, partial failures, and similar information on each GetOperation call. The metadata type should not be google.protobuf.Empty, unless it is certain that metadata will never be needed. If metadata might be added in the future, define an empty message for the RPC metadata and use that. APIs with messages that return Operation must implement the GetOperation method of the Operations service, and may implement the other methods defined in that service. Individual APIs must not define their own interfaces for long-running operations to avoid inconsistency. OpenAPI 3.0 paths: /v1/resources: post: operationId: write_book description: Write a book. responses: 202: description: OK content: application/json: schema: $ref: \u0027#/components/schemas/WriteBookStatus\u0027 202 must be the only success status code defined. The 202 response must define an application/json response body and no other response content types. The response body schema must be an object with path, done, error, and response properties as described above for an Operation. The response body schema may contain an object property named metadata to hold service-specific metadata associated with the operation, for example progress information and common metadata such as create time. The service should define the contents of the metadata object in a separate schema, which should specify additionalProperties: true to allow for future extensibility. The response property must be a schema that defines the success response for the operation. For an operation that typically gives a 204 No Content response, such as a Delete, response should be defined as an empty object schema. For a standard Get/Create/Update operation, response should be a representation of the resource. If a service has any long running operations, the service must define an Operation resource with a list operation to retrieve a potentially filtered list of operations and a get operation to retrieve a specific operation by its path.",
    'tags': '',
    'url': '/151',
  },
{
    'title': "Resource freshness validation",
    'text': "Resource freshness validation APIs often need to validate that a client and server agree on the current state of a resource before taking some kind of action on that resource. For example, two processes updating the same resource in parallel could create a race condition, where the latter process \"stomps over\" the effort of the former one. ETags provide a way to deal with this, by allowing the server to send a checksum based on the current content of a resource; when the client sends that checksum back, the server can ensure that the checksums match before acting on the request. Guidance A resource may provide an ETag header when retrieving a single resource when it is important to ensure that the client has an up to date resource before acting on certain requests: 200 OK Content-type: application/json ETag: \"55cc0347-66fc-46c3-a26f-98a9a7d61d0e\" The ETag must be provided by the server on output, and values should conform to RFC 7232. Resources must support the If-Match header (and may support the If-None-Match header) if and only if resources provide the ETag. Note: ETag values must include quotes as described in RFC 7232. For example, a valid ETag is \"foo\", not foo. ETags must be based on an opaque checksum or hash of the resource that guarantees it will change if the resource changes. Condition headers Services that provide ETags should support the If-Match and If-None-Match headers on incoming requests: GET /v1/publishers/{publisher}/books/{book} HTTP/2 Host: library.googleapis.com Accept: application/json If-Match: \"55cc0347-66fc-46c3-a26f-98a9a7d61d0e\" If the service receives a request to modify a resource that includes an If-Match header, the service must validate that the value matches the current ETag. If the If-Match header value does not match the ETag, the service must reply with an HTTP 412 error. If the user omits the If-Match header, the service should permit the request. However, services with strong consistency or parallelism requirements may require users to send ETags all the time and reject the request with an HTTP 400 error if it does not contain an ETag. If any conditional headers are supported for any operation within a service, the same conditional headers must be supported for all mutation methods (POST, PATCH, PUT, and DELETE) of any path that supports them, and should be supported uniformly for all operations across the service. If any validator or conditional headers are supported for any operations in the service, the use of unsupported conditional headers must result in an error. (In other words, once a service gives the client reason to believe it understands conditional headers, it must not ever ignore them.) Read requests If a service receives a GET or HEAD request with an If-Match header, the service must proceed with the request if the ETag matches, or send a 412 Precondition Failed error if the ETag does not match. If a service receives a GET or HEAD request with an If-None-Match header, the service must proceed with the request if the ETag does not match, or return a 304 Not Modified response if the ETag does match. Strong and weak ETags ETags can be either \"strongly validated\" or \"weakly validated\": A strongly validated ETag means that two resources bearing the same ETag are byte-for-byte identical. A weakly validated ETag means that two resources bearing the same ETag are equivalent, but may differ in ways that the service does not consider to be important. Resources may use either strong or weak ETags, as it sees fit, but should document the behavior. Additionally, weak ETags must have a W/ prefix as mandated by RFC 7232: 200 OK Content-type: application/json ETag: W/\"55cc0347-66fc-46c3-a26f-98a9a7d61d0e\" Strong ETags must and weak ETags should be guaranteed to change if any properties on the resource change that are directly mutable by the client. Additionally, strong ETags should be guaranteed to change if the resource\u0027s representation changes in a meaningful way (meaning the new representation is not equivalent to the old one). Further reading For how to retry on errors in client libraries, see AEP-194. Changelog 2020-09-02: Clarified that other errors may take precedence over FAILED_PRECONDITION for ETag mismatches. 2020-09-02: Add guidance for ETags on request messages. 2019-09-23: Changed the title to \"resource freshness validation\".",
    'tags': '',
    'url': '/154',
  },
{
    'title': "Idempotency",
    'text': "Idempotency It is sometimes useful for an API to have a unique, customer-provided identifier for particular requests. This can be useful for several purposes, such as: De-duplicating requests from parallel processes Ensuring the safety of retries Auditing The purpose of idempotency keys is to provide idempotency guarantees: allowing the same request to be issued more than once without subsequent calls having any effect. In the event of a network failure, the client can retry the request, and the server can detect duplication and ensure that the request is only processed once. Guidance APIs may add a aep.api.IdempotencyKey idempotency_key parameter to request messages (including those of standard methods) in order to uniquely identify particular requests. API servers must not execute requests with the same idempotency_key more than once. message CreateBookRequest { // The parent resource where this book will be created. // Format: publishers/{publisher} string parent = 1 [ (google.api.field_behavior) = REQUIRED, (google.api.resource_reference) = { child_type: \"library.example.com/Book\" }]; // The book to create. Book book = 2 [(google.api.field_behavior) = REQUIRED]; // This request is only idempotent if `idempotency_key` is provided. // // This key will be honored for at least one hour after the first time it is // seen by the server. // // The key is restricted to 36 ASCII characters. A random UUID is recommended. aep.api.IdempotencyKey idempotency_key = 3 [ (aep.api.field_info).minimum_lifetime = { seconds: 3600 } ]; } [aep.api.IdempotencyKey][] has a key and a first_sent timestamp. key is simply a unique identifier. Providing an idempotency key must guarantee idempotency. If a duplicate request is detected, the server must return one of: A response equivalent to the response for the previously successful request, because the client most likely did not receive the previous response. An error indicating that the first_sent field of the idempotency key is invalid or cannot be honored (expired, in the future, or differs from a previous first_sent value with the same key). An error, if returning an equivalent response is not possible. For example, if a resource was created, then deleted, and then a duplicate request to create the resource is received, the server may return an error if returning the previously created resource is not possible. APIs should honor idempotency keys for at least an hour. When using protocol buffers, idempotency keys that are UUIDs must be annotated with a minimum lifetime using the extension [(aep.api.field_info).minimum_lifetime][]. The idempotency_key field must be provided on the request message to which it applies (and it must not be a field on resources themselves). The first_sent field can be used by API servers to determine if a key is expired. API servers must reject requests with expired keys, and must reject requests with keys that are in the future. When feasible, API servers should reject requests that use the same key but have a different first_sent timestamp. The key field must be able to be a UUID, and may allow UUIDs to be the only valid format. The format restrictions for idempotency keys must be documented. Idempotency keys should be optional. Further reading For which codes to retry, see AEP-194. For how to retry errors in client libraries, see AEP-4221. Rationale Naming the field idempotency_key The original content from which this AEP is derived defines a request_id field; we define idempotency_key instead for two reasons: There is an active Internet-Draft to standardize an HTTP header named Idempotency-Key. There may be edge cases in which separately identifying idempotent requests is useful; request_id would be more appropriate for such use cases. For example, an API producer might be testing the idempotency behavior of the API server, and might want to issue multiple requests with the same idempotency_key and trace the behavior of each request separately. Using UUIDs for request identification When a value is required to be unique, leaving the format open-ended can lead to API consumers incorrectly providing a duplicate identifier. As such, standardizing on a universally unique identifier drastically reduces the chance for collisions when done correctly. Changelog 2023-23-20: Adopt AEP from from Google\u0027s AIP with the following changes: Rename field from request_id to idempotency_key (plus some minor releated rewording). Add a common component [aep.api.IdempotencyKey][] and use this rather than string for the idempotency_key field; add related guidance about IdempotencyKey.first_seen. Remove guidance about annotating idempotency_key with (google.api.field_info).format. Add guidance about annotating idempotency_key with [(aep.api.field_info).minimum_lifetime]. Update guidance about responses to be more explicit about success and error cases, while allowing \"equivalent\" rather than identical responses for subsequent requests. Temporarily removed the section about stale success responses, pending further discussion. 2023-10-02: Add UUID format extension guidance. 2019-08-01: Changed the examples from \"shelves\" to \"publishers\", to present a better example of resource ownership.",
    'tags': '',
    'url': '/155',
  },
{
    'title': "Partial responses",
    'text': "Partial responses Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/157',
  },
{
    'title': "Pagination",
    'text': "Pagination APIs often need to provide collections of data, most commonly in the [List][aip-132] standard method. However, collections can often be arbitrarily sized, and also often grow over time, increasing lookup time as well as the size of the responses being sent over the wire. Therefore, it is important that collections be paginated. Guidance Operations returning collections of data must provide pagination at the outset, as it is a backwards-incompatible change to add pagination to an existing method. // The request structure for listing books. interface ListBooksRequest { // The parent, which owns this collection of books. // Format: publishers/{publisher} parent: string; // The maximum number of books to return. The service may return fewer than // this value. // If unspecified, at most 50 books will be returned. // The maximum value is 1000; values above 1000 will be coerced to 1000. maxPageSize: bigint; // A page token, received from a previous `ListBooks` call. // Provide this to retrieve the subsequent page. // // When paginating, all other parameters provided to `ListBooks` must match // the call that provided the page token. pageToken: string; } // The response structure from listing books. interface ListBooksResponse { // The books from the specified publisher. books: Book[]; // A token that can be sent as `page_token` to retrieve the next page. // If this field is omitted, there are no subsequent pages. nextPageToken: string; } Request definitions for collections should define an int32 max_page_size field, allowing users to specify the maximum number of results to return. If the user does not specify max_page_size (or specifies 0), the API chooses an appropriate default, which the API should document. The API must not return an error. If the user specifies max_page_size greater than the maximum permitted by the service, the service should coerce down to the maximum permitted page size. If the user specifies a negative value for max_page_size, the API must return a 400 Bad Request error. The service should the number of results requested, unless the end of the collection is reached. However, occasionally this is infeasible, especially within expected time limits. In these cases, the service may return fewer results than the number requested (including zero results), even if not at the end of the collection. Request definitions for collections should define a string page_token field, allowing users to advance to the next page in the collection. If the user changes the max_page_size in a request for subsequent pages, the service must honor the new page size. The user is expected to keep all other arguments to the operation request the same; if any arguments are different, the API should send a 400 Bad Request error. The response must not be a streaming response. Services may support using page tokens across versions of a service, but are not required to do so. Response definitions for collections must define a string next_page_token field, providing the user with a page token that may be used to retrieve the next page. The field containing pagination results should be the first field specified. It should be a repeated field containing a list of resources constituting a single page of results. If the end of the collection has been reached, the next_page_token field must be empty. This is the only way to communicate \"end-of-collection\" to users. If the end of the collection has not been reached (or if the API can not determine in time), the service must provide a next_page_token. Response definitions may include a string next_page_url field containing the full URL for the next page. Response definitions for collections may provide an int32 total_size field, providing the user with the total number of items in the list. This total may be an estimate (but the API should explicitly document that). Skipping results The request definition for a paginatied operation may define an int32 skip field to allow the user to skip results. The skip value must refer to the number of individual resources to skip, not the number of pages. For example: A request with no page token and a skip value of 30 returns a single page of results starting with the 31st result. A request with a page token corresponding to the 51st result (because the first 50 results were returned on the first page) and a skip value of 30 returns a single page of results starting with the 81st result. If a skip value is provided that causes the cursor to move past the end of the collection of results, the response must be 200 OK with an empty result set, and not provide a next_page_token. Opacity Page tokens provided by services must be opaque (but URL-safe) strings, and must not be user-parseable. This is because if users are able to deconstruct these, they will do so. This effectively makes the implementation details of your API\u0027s pagination become part of the API surface, and it becomes impossible to update those details without breaking users. Warning: Base-64 encoding an otherwise-transparent page token is not a sufficient obfuscation mechanism. For page tokens which do not need to be stored in a database, and which do not contain sensitive data, an API may obfuscate the page token by defining an internal protocol buffer message with any data needed, and send the serialized proto, base-64 encoded. Page tokens must be limited to providing an indication of where to continue the pagination process only. They must not provide any form of authorization to the underlying resources, and authorization must be performed on the request as with any other regardless of the presence of a page token. Expiring page tokens Many services store page tokens in a database internally. In this situation, the service may expire page tokens a reasonable time after they have been sent, in order not to needlessly store large amounts of data that is unlikely to be used. It is not necessary to document this behavior. Note: While a reasonable time may vary between services, a good rule of thumb is three days. Consistency When discussing pagination, consistency refers to the question of what to do if the underlying collection is modified while pagination is in progress. The most common way that this occurs is for a resource to be added or deleted in a place that the pagination cursor has already passed. Services may choose to be strongly consistent by approximating the \"repeatable read\" behavior in databases, and returning exactly the records that exist at the time that pagination begins. Backwards compatibility Adding pagination to an existing operation is a backwards-incompatible change. This may seem strange; adding fields to interface definitions is generally backwards compatible. However, this change is behaviorally incompatible. Consider a user whose collection has 75 resources, and who has already written and deployed code. If the API later adds pagination fields, and sets the default to 50, then that user\u0027s code breaks; it was getting all resources, and now is only getting the first 50 (and does not know to advance pagination). Even if the API set a higher default limit, such as 100, the user\u0027s collection could grow, and then the code would break. For this reason, it is important to always add pagination to operations returning collections up front; they are consistently important, and they can not be added later without causing problems for existing users. Warning: This also entails that, in addition to presenting the pagination fields, they must be actually implemented with a non-infinite default value. Implementing an in-memory version (which might fetch everything then paginate) is reasonable for initially-small collections. Implementation Page tokens should be versioned independently of the public API, so that page tokens can be used with any version of the service. The simplest form of a page token only requires an offset. However, offsets pose challenges when a distributed database is introduced, so a more robust page token needs to store the information needed to find a \"logical\" position in the database. The simplest way to do this is to include relevant data from the last result returned. Primarily, this means the resource ID, but also includes any other fields from the resource used to sort the results (for the event where the resource is changed or deleted). This information is from the resource itself, and therefore might be sensitive. Sensitive data must be encrypted before being used in a page token. Therefore, the token also includes the date it was created, to allow for the potential need to rotate the encryption key. This yields the following interface, which may be base64 encoded and used as a page token: interface PageTokenSecrets { // The ID of the most recent resource returned. lastId: string; // Any index data needed, generally 1:1 with the fields used for ordering. indexData: Buffer[]; // When this token was minted. createTime: Date; } Note: This section does not preclude alternative page token implementations provided they conform to the guidelines discussed in this document.",
    'tags': '',
    'url': '/158',
  },
{
    'title': "Reading across collections",
    'text': "Reading across collections Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/159',
  },
{
    'title': "Filtering",
    'text': "Filtering Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/160',
  },
{
    'title': "Field masks",
    'text': "Field masks Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/161',
  },
{
    'title': "Resource Revisions",
    'text': "Resource Revisions Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/162',
  },
{
    'title': "Soft delete",
    'text': "Soft delete There are several reasons why a client could desire soft delete and undelete functionality, but one over-arching reason stands out: recovery from mistakes. A service that supports undelete makes it possible for users to recover resources that were deleted by accident. Guidance Services may support the ability to \"undelete\", to allow for situations where users mistakenly delete resources and need the ability to recover. If a resource needs to support undelete, the Delete method must simply mark the resource as having been deleted, but not completely remove it from the system. If the method behaves this way, it should return 200 OK with the updated resource instead of 204 No Content. Resources that support soft delete should have an expire_time field as described in AEP-148. Additionally, resources should include a DELETED state value if the resource includes a state field (AEP-216). Undelete A resource that supports soft delete should provide an Undelete method: Protocol buffers // Undelete a single book. rpc UndeleteBook(UndeleteBookRequest) returns (Book) { option (google.api.http) = { post: \"/v1/{name=publishers/*/books/*}:undelete\" body: \"*\" }; option (google.api.method_signature) = \"name\"; } // Request message to undelete a single book. message UndeleteBookRequest { // The name of the book to undelete. // The book must exist and currently be deleted (but not expunged). string name = 1 [ (google.api.field_behavior) = REQUIRED, (google.api.resource_reference) = { type: \"library.googleapis.com/Book\" }]; } The HTTP method must be POST. The body clause must be \"*\". The response message must be the resource itself. There is no UndeleteBookResponse. The response should include the fully-populated resource unless it is infeasible to do so. If the undelete RPC is long-running, the response message must be a google.longrunning.Operation which resolves to the resource itself. A name field must be included in the request message; it should be called name. The field should be [annotated as required][aip-203]. The field should identify the [resource type][aip-123] that it references. The comment for the field should document the resource pattern. The request message must not contain any other required fields, and should not contain other optional fields except those described in this or another AEP. OpenAPI 3.0 paths: /publishers/{publisherId}/books/{bookId}:undelete: post: operationId: undeleteBook description: Undelete a single book. responses: 200: description: OK content: application/json: schema: $ref: \u0027#/components/schemas/Book\u0027 The HTTP method must be POST. The response message must be the resource itself. The response should include the fully-populated resource unless it is infeasible to do so. The operation must not require any other fields, and should not contain other optional query parameters except those described in this or another AEP. Long-running undelete Some resources take longer to undelete a resource than is reasonable for a regular API request. In this situation, the API should follow the long-running request pattern (AEP-151). List and Get Soft-deleted resources should not be returned in List (AEP-132) responses by default (unless bool show_deleted is true). A Get (AEP-131) request for a soft deleted resource should error with 410 Gone unless bool show_deleted is true, in which case soft-deleted resources must return the resource. Services that soft delete resources may choose a reasonable strategy for purging those resources, including automatic purging after a reasonable time (such as 30 days), allowing users to set an expiry time (AEP-214), or retaining the resources indefinitely. Regardless of what strategy is selected, the service should document when soft deleted resources will be completely removed. Declarative-friendly resources A resource that is declarative-friendly (AEP-128) should support soft delete and undelete. Important: There is an ambiguity in declarative tooling between \"create\" and \"undelete\". When given an alias which was previously deleted and a directive to make it exist, tooling usually does not know if the intent is to restore the previously-deleted resource, or create a new one with the same alias. Declarative tools should resolve this ambiguity in favor of creating a new resource: the only way to undelete is to explicitly use the undelete RPC (an imperative operation), and declarative tools may elect not to map anything to undelete at all. Declarative-friendly resources must use long-running operations for both soft delete and undelete. The service may return an LRO that is already set to done if the request is effectively immediate. Declarative-friendly resources must include validate_only (AEP-163) and etag (AEP-154) in their Undelete methods. Errors If the user does not have permission to access the resource, regardless of whether or not it exists, the service must error with 403 Forbidden. Permission must be checked prior to checking if the resource exists. If the user does have proper permission, but the requested resource does not exist (either it was never created or already expunged), the service must error with 404 Not Found. If the user calling a soft Delete has proper permission, but the requested resource is already deleted, the service must succeed if allow_missing is true, and should error with 404 Not Found if allow_missing is false. If the user calling Undelete has proper permission, but the requested resource is not deleted, the service must error with 409 Conflict. Further reading For the Delete standard method, see AEP-135. For long-running operations, see AEP-151. For resource freshness validation (etag), see AEP-154. For change validation (validate_only), see AEP-163.",
    'tags': '',
    'url': '/164',
  },
{
    'title': "Backwards compatibility",
    'text': "Backwards compatibility Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/180',
  },
{
    'title': "Stability levels",
    'text': "Stability levels Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/181',
  },
{
    'title': "File and directory structure",
    'text': "File and directory structure Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/191',
  },
{
    'title': "Documentation",
    'text': "Documentation Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/192',
  },
{
    'title': "Errors",
    'text': "Errors Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/193',
  },
{
    'title': "Precedent",
    'text': "Precedent Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/200',
  },
{
    'title': "Field behavior documentation",
    'text': "Field behavior documentation Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/203',
  },
{
    'title': "Beta-blocking changes",
    'text': "Beta-blocking changes Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/205',
  },
{
    'title': "Unicode",
    'text': "Unicode APIs should be consistent on how they explain, limit, and bill for string values and their encodings. This ranges from little ambiguities (like fields \"limited to 1024 characters\") all the way to billing confusion (are names and values of properties in Datastore billed based on characters or bytes?). In general, if limits are measured in bytes, we are discriminating against non-ASCII text since it takes up more space. On the other hand, if limits are measured in \"characters\", this is ambiguous about whether those are Unicode \"code points\", \"code units\" for a particular encoding (e.g. UTF-8 or UTF-16), \"graphemes\", or \"grapheme clusters\". Unicode primer Character encoding tends to be an area we often gloss over, so a quick primer: Strings are just sequences of bytes that represent text according to some encoding format. When we talk about characters, we sometimes mean Unicode code points, which are 21-bit unsigned integers 0 through 0x10FFFF. Other times we might mean grapheme clusters, which are perceived as single characters but may be composed of multiple code points. For example, \u00e1 can be represented as the single code point U+00E1 or as a sequence of U+0061 followed by U+0301 (the letter a, then a combining acute accent). Protocol buffers uses UTF-8 (\"Unicode Transformation Format\") which is a variable-length encoding scheme that represents each code point as a sequence of 1 to 4 single-byte code units. Guidance Character definition TL;DR: In our APIs, \"character\" means \"Unicode code point\". In API documentation (e.g., API reference documents, blog posts, marketing documentation, billing explanations, etc), \"character\" must be defined as a Unicode code point. Length units TL;DR: Set size limits in \"characters\" (as defined above). All string field length limits defined in the API must be measured and enforced in characters as defined above. This means that there is an underlying maximum limit of (4 * characters) bytes, though this limit will only be hit when using exclusively characters that consist of 4 UTF-8 code units (32 bits). If you use a database system (e.g. Spanner) which allows you to define a limit in characters, it is safe to assume that this byte-defined requirement is handled by the underlying storage system. Billing units APIs may use either code points or bytes (using the UTF-8 encoding) as the unit for billing or quota measurement (e.g., Cloud Translation chooses to use characters). If an API does not define this, the assumption is that the unit of billing is characters (e.g., $0.01 per character, not $0.01 per byte). Unique identifiers TL;DR: Unique identifiers should limit to ASCII, generally only letters, numbers, hyphens, and underscores. Additionally, unique identifiers should start with a letter, should end in either a letter or number, and should not have hyphens or underscores that are next to other hyphens or underscores. Strings used as unique identifiers should limit inputs to ASCII characters, typically letters, numbers, hyphens, and underscores ([a-zA-Z][a-zA-Z0-9_-]*). This ensures that there are never accidental collisions due to normalization. If an API decides to allow all valid Unicode characters in unique identifiers, the API must reject any inputs that are not in Normalization Form C. Unique identifiers should use a maximum length of 64 characters, though this limit may be expanded as necessary. 64 characters should be sufficient for most purposes as even UUIDs only require 36 characters. Normalization TL;DR: Unicode values should be stored in Normalization Form C. Values should always be normalized into Normalization Form C. Unique identifiers must always be stored in Normalization Form C (see the next section). Imagine we\u0027re dealing with Spanish input \"estar\u00e9\" (the accented part will be bolded throughout). This text has 6 grapheme clusters, and can be represented by two distinct sequences of Unicode code points: Using 6 code points: U+0065 U+0073 U+0074 U+0061 U+0072 U+00E9 Using 7 code points: U+0065 U+0073 U+0074 U+0061 U+0072 U+0065 U+0301 Further, when encoding to UTF-8, these code points have two different serialized representations: Using 7 code-units (7 bytes): 0x65 0x73 0x74 0x61 0x72 0xC3 0xA9 Using 8 code-units (8 bytes): 0x65 0x73 0x74 0x61 0x72 0x65 0xCC 0x81 To avoid this discrepancy in size (both code units and code points), use Normalization Form C which provides a canonical representation for strings. Uniqueness TL;DR: Unicode values must be normalized to Normalization Form C before checking uniqueness. For the purposes of unique identification (e.g., name, id, or parent), the value must be normalized into Normalization Form C (which happens to be the most compact). Otherwise we may have what is essentially \"the same string\" used to identify two entirely different resources. In our example above, there are two ways of representing what is essentially the same text. This raises the question about whether the two representations should be treated as equivalent or not. In other words, if someone were to use both of those byte sequences in a string field that acts as a unique identifier, would it violate a uniqueness constraint? The W3C recommends using Normalization Form C for all content moving across the internet. It is the most compact normalized form on Unicode text, and avoids most interoperability problems. If we were to treat two Unicode byte sequences as different when they have the same representation in NFC, we\u0027d be required to reply to possible \"Get\" requests with content that is not in normalized form. Since that is definitely unacceptable, we must treat the two as identical by transforming any incoming string data into Normalized Form C or rejecting identifiers not in the normalized form. There is some debate about whether we should view strings as sequences of code points encoded into byte sequences (leading to uniqueness determined based on the byte-representation of said string) or to interpret strings as a higher level abstraction having many different possible byte-representations. The stance taken here is that we already have a field type for handling that: bytes. Fields of type string already express an opinion of the validity of an input (it must be valid UTF-8). As a result, treating two inputs that have identical normalized forms as different due to their underlying byte representation seems to go against the original intent of the string type. This distinction typically doesn\u0027t matter for strings that are opaque to our services (e.g., description or display_name), however when we rely on strings to uniquely identify resources, we are forced to take a stance. Put differently, our goal is to allow someone with text in any encoding (ASCII, UTF-16, UTF-32, etc) to interact with our APIs without a lot of \"gotchas\". References Unicode normalization forms Datastore pricing \"name and value of each property\" doesn\u0027t clarify this. Natural Language pricing uses charges based on UTF-8 code points rather than code units. Text matching and normalization",
    'tags': '',
    'url': '/210',
  },
{
    'title': "Authorization checks",
    'text': "Authorization checks The majority of operations, whether reads or writes, require authorization: permission to do the thing the user is asking to do. Additionally, it is important to be careful how much information is provided to unauthorized users, since leaking information can be a security concern. Guidance Services must check authorization before validating any request, to ensure both a secure API surface and a consistent user experience. An operation may require multiple permissions or preconditions in order to grant authorization. If a request can not pass the authorization check for any reason, the service should error with 403 Forbidden, and the corresponding error message should look like: \"Permission {p} denied on resource {r} (or it might not exist).\" This avoids leaking resource existence. If it is not possible to determine authorization for a resource because the resource does not exist, the service should check authorization to read children on the parent resource, and return 404 Not Found if the authorization check passes. Multiple operations A service could encounter a situation where it has two different operations with two different permissions, either of which would reveal the existence of a resource if called, but a user only has permission to call one of them. In this situation, the service should still only check for authorization applicable to the operation being called, and should not try to \"help out\" by checking for related authorization that would provide permission to reveal existence, because such algorithms are complicated to implement correctly and prone to accidental leaks. For example, posit a scenario where: A resource exists within a given collection that a user is unable to read. The user does have the ability to create other resources, and the collection uses user-specified IDs (meaning that a failure because of a duplicate ID would reveal existance). In this situation, the get or create methods should still only check their permissions when determining what error to return, and not one another\u0027s. Rationale RFC 7231 \u00a76.5.3 states that services are permitted to use 404 Not Found in lieu of 403 Forbidden in situations where the service does not want to divulge existance, whereas this AEP argues for the use of 403 Forbidden instead. We take this position for the following reasons: The practice of \"getting 404 Not Found until you have enough permission to get 403 Forbidden\" is counter-intuitive and increases the difficulty of troubleshooting. A service could ameliorate this by sending information about missing permissions while still using the 404 Not Found status code, but this constitutes a mixed message. While 403 Forbidden is essentially always an error requiring manual action, 404 Not Found is often a valid response that the application can handle (e.g. \"get or create\"); overloading it for permission errors deprives applications of this benefit. RFC 7231 \u00a76.5.4 states that 404 Not Found results are cacheable, but permission errors are not generally cacheable. Sending explicit cache controls on a conditional basis could ameliorate this, but would defeat the purpose. The guidance here is more consistent with most other real-world authorization systems.",
    'tags': '',
    'url': '/211',
  },
{
    'title': "Common components",
    'text': "Common components Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/213',
  },
{
    'title': "Resource expiration",
    'text': "Resource expiration Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/214',
  },
{
    'title': "Common component versions",
    'text': "Common component versions Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/215',
  },
{
    'title': "States",
    'text': "States Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/216',
  },
{
    'title': "Unreachable resources",
    'text': "Unreachable resources Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/217',
  },
{
    'title': "Batch methods: Get",
    'text': "Batch methods: Get Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/231',
  },
{
    'title': "Batch methods: Create",
    'text': "Batch methods: Create Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/233',
  },
{
    'title': "Batch methods: Update",
    'text': "Batch methods: Update Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/234',
  },
{
    'title': "Batch methods: Delete",
    'text': "Batch methods: Delete Note: This AEP has not yet been adopted. See this GitHub issue for more information.",
    'tags': '',
    'url': '/235',
  },
]};